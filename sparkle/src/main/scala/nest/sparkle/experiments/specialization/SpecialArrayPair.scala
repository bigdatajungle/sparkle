package nest.sparkle.experiments.specialization

import scala.reflect.{ ClassTag, classTag }
import scala.{ specialized => spec }

case class SpecialDataArray[K: ClassTag, V: ClassTag](keys: Array[K], values: Array[V]) {
  self =>

  /** What follows are some experiments with specialization, explaining how we can use
    * a combination of specialization and dynamic casting to code generic functions that run fast
    * on SpecialDataArrays.
    *
    * The goal is to get a fast version of the mapValues function.
    *
    * TL;DR the mapValuesDynCastSpecialize function looks like our winner. It's statically typechecked,
    * and so it's safe. It forwards the call to a specialized but type-unsafe variant and so it's fast.
    * (It forwards to a generic boxed version if no specialization is available). The implementation
    * seems manageable: a couple of lines have to be copy-pasted for each type variant, but
    * specialization does most of the work.
    */

  /** Apply A function that maps A key and value to A new value, and return the resulting SpecialDataArray.
    * This is an initial attempt at providing A standard function over the SpecialDataArray that runs fast.
    *
    * We're using a function from (key,value)=>value so that we can hope to run without boxing. If we
    * returned a (key,value) we'd need to create and return a Tuple instance for each iteration.
    *
    * TODO This is not yet as fast and low memory as A non-generic version would be, more optimization
    * is available. The arrays themselves are specialized, which is dense and fast. But the function call
    * the caller provides is not specialized. See below for some fast approaches.
    */
  def mapValues   // format: OFF 
      [@spec(Double) A: ClassTag]     
      (fn: (K, V) => A)
      : SpecialDataArray[K, A] = { // format: ON
    // this is A bit extra verbose, intentionally, so we can review the generated bytecode

    val length = keys.length
    /* Here's the bytecode for the double specialized version generated by the compiler:
        17: invokeinterface #43,  2           // InterfaceMethod scala/reflect/ClassTag.newArray:(I)Ljava/lang/Object;

       // it's created an array of the appropriate primitive type. Dense storage and fast, nice:
        22: checkcast     #126                // class "[D"     
     */
    val newValues = new Array[A](length)
    var i = 0

    while (i < keys.length) {
      val key = keys(i)
      val value = values(i)

      /* This is not specialized on the way in or out. We're boxing both ways.
          //  We call A generic function interface:
          72: invokeinterface #55,  3           // InterfaceMethod scala/Function2.apply:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
          
          // and we box the result:
          77: invokestatic  #130                // Method scala/runtime/BoxesRunTime.unboxToDouble:(Ljava/lang/Object;)D      
       */
      val result = fn(key, value)
      newValues(i) = result
      i += 1
    }
    SpecialDataArray(keys, newValues)
  }

  /** Here's A non-generic version of this routine, this looks to be fairly optimal from a bytecode perspective.
    * (We'll need to benchmark to be absolutely certain.)
    *
    * The problem is that this version uses a single fixed type that the caller needs to follow. We'd need
    * to make multiple versions of these, we'd need the callers to select which one to use, and we'd need to
    * propagate mulitple typed versions through the container interfaces.
    *
    * So this shows how to be fast, but it isn't the solution we'd want to use generally.
    */
  def mapValuesLongLongDouble// format: OFF
      (fn: (Long, Long) => Double)
      : SpecialDataArray[Long, Double] = { // format: ON

    val castKeys = keys.asInstanceOf[Array[Long]]
    val castValues = values.asInstanceOf[Array[Long]]
    val length = castKeys.length
    val newValues = new Array[Double](length)
    var i = 0

    while (i < length) {
      val key = castKeys(i)
      val value = castValues(i)
      /* This looks fast. We're calling the (Long,Long)=>Double specialized version of Function2.
       *       51: invokeinterface #82,  5           // InterfaceMethod scala/Function2.apply$mcDJJ$sp:(JJ)D
       */
      val result = fn(key, value)
      newValues(i) = result
      i += 1
    }
    SpecialDataArray(castKeys, newValues)
  }

  /** Here's a generic version, but it isn't fast, even if we specialize K and V in SpecialDataArray.
    * SCALA -- is this fixed in 2.11?
    *
    * This isn't our solution (unless specialization gets smarter in a later version of the compiler. this was tested with 2.10.4).
    */
  def mapValuesSpecialNoCast  // format: OFF
      [@spec(Double) C: ClassTag]
      (fn: (K, V) => C)
      : SpecialDataArray[K, C] = { // format: ON
    val length = keys.length
    val newValues = new Array[C](length)
    var i = 0

    while (i < length) {
      val key = keys(i)
      val value = values(i)
      /* this boxes. Not fast. (With K, and V specialized:)
       
        public nest.sparkle.core.SpecialDataArray<K, java.lang.Object> mapValuesSpecialNoCast$mDc$sp(scala.Function2<K, V, java.lang.Object>, scala.reflect.ClassTag<java.lang.Object>);
  
        65: invokeinterface #55,  3           // InterfaceMethod scala/Function2.apply:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
        70: invokestatic  #154                // Method scala/runtime/BoxesRunTime.unboxToDouble:(Ljava/lang/Object;)D
  
      */
      val result = fn(key, value)
      newValues(i) = result
      i += 1
    }
    SpecialDataArray(keys, newValues)
  }

  /** Here's a generic version of this routine, achieved via casting.
    * It's fast, but not typesafe. Type parameters A and B might not really be K and V
    * SCALA is there a way to arrange for type A to be K, and still be specialised?
    *
    * This isn't typesafe, so not so great a solution by itself. It's nice that the compiler will
    * generate fast specialized versions of the code for us though. We'll take advantage of that
    * a bit lower down.
    */
  def mapValuesSpecialCast  // format: OFF
      [@spec(Long) A:ClassTag, @spec(Long) B:ClassTag, @spec(Double) C: ClassTag]
      (fn: (A, B) => C)
      : SpecialDataArray[A, C] = { // format: ON
    val castKeys = keys.asInstanceOf[Array[A]]
    val castValues = values.asInstanceOf[Array[B]]
    val length = castKeys.length
    val newValues = new Array[C](length)
    var i = 0

    while (i < length) {
      val key = castKeys(i)
      val value = castValues(i)
      /* looks fast: (we call the specialized version of Function2, no boxing in or out)
            62: invokeinterface #82,  5           // InterfaceMethod scala/Function2.apply$mcDJJ$sp:(JJ)D
      */
      val result = fn(key, value)
      newValues(i) = result
      i += 1
    }
    SpecialDataArray(castKeys, newValues)
  }

  /** This version dynamically matches on the types of the keys, values, and target value type.
    *
    * It matches the types at runtime, and then calls the appropriate fast specialized version. We have
    * to copy/paste only the bridge functions. This is the technique I plan to try and use.
    */
  def mapValuesDynCastSpecialize // format: OFF
      [C: ClassTag]
      (fn: (K, V) => C)
      : SpecialDataArray[K, C] = { // format: ON

    // SCALA we really just want to match on K and V here, but that doesn't compile. 
    // Sow here we pass along an A,B. With this layer of indirection, it works. 

    /** match on the type of K,V,C and call the appropriate specialized version */
    def callTypedVariant[A, B](ks: Array[A], vs: Array[B]): SpecialDataArray[K, C] = {
      (ks, vs, classTag[C]) match {
        // (Long,Long)=>Double : call the specialized version
        case (_: Array[Long], _: Array[Long], tag) if tag == classTag[Double] =>
          val castFn = fn.asInstanceOf[(Long, Long) => Double]
          val result: SpecialDataArray[Long, Double] = mapValuesSpecialCast(castFn)
          result.asInstanceOf[SpecialDataArray[K, C]]

        // (Long,Long)=>Long : call the specialized version
        case (_: Array[Long], _: Array[Long], tag) if tag == classTag[Long] =>
          val castFn = fn.asInstanceOf[(Long, Long) => Long]
          mapValuesSpecialCast(castFn).asInstanceOf[SpecialDataArray[K, C]]

        // no specialized version available, call the generic version
        case _ => mapValues(fn)
      }
    }

    callTypedVariant(keys, values)
  }

}